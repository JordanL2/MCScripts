#!/usr/bin/python3

from nbt.nbt import *
from nbt.region import *

import math
import os.path
import sys


def info(*messages):
    print("{}".format(' '.join([str(m) for m in messages])), file=sys.stderr)

def fatal(*messages):
    print("ERROR", file=sys.stderr)
    print("{}".format(' '.join([str(m) for m in messages])), file=sys.stderr)
    sys.exit(1)

def repr_uuid(uuid):
    return '-'.join([str(hex(i if i >= 0 else i + 2**32))[2:] for i in uuid])


scriptpath = sys.argv.pop(0)
if len(sys.argv) < 4:
    fatal("Usage: villager_info <PATH/TO/MC/SAVE> <X> <Z> <RADIUS>")
mcsave = sys.argv.pop(0)
x = int(sys.argv.pop(0))
z = int(sys.argv.pop(0))
r = int(sys.argv.pop(0))

sort_dim = 'z'
sort_reverse = False
use_last_modified = 0
show_uuid = False
for a in sys.argv:
    i = a.index('=')
    k = a[0 : i]
    v = a[i + 1:]
    if k == 'sort':
        if v in ['x', 'y', 'z', 'age', 'health']:
            sort_dim = v
        else:
            fatal("No such sort value: '{}'".format(v))
    elif k == 'reverse':
        if v in ['true', 'false']:
            sort_reverse = (v == 'true')
        else:
            fatal("No such reverse value: '{}'".format(v))
    elif k == 'use_last_modified':
        if v in ['true', 'false']:
            use_last_modified = 0
            if v == 'true':
                use_last_modified = 1
        else:
            fatal("No such use_last_modified value: '{}'".format(v))
    elif k == 'show_uuid':
        if v in ['true', 'false']:
            show_uuid = (v == 'true')
        else:
            fatal("No such show_uuid value: '{}'".format(v))
    else:
        fatal("No such argument: '{}'".format(k))

region_files = "{}/region".format(mcsave)

minx = x - r
maxx = x + r
minz = z - r
maxz = z + r
info("Searching blocks: {},{} to {},{}".format(minx, minz, maxx, maxz))

minx_chunk = math.floor(minx / 16)
maxx_chunk = math.floor(maxx / 16)
minz_chunk = math.floor(minz / 16)
maxz_chunk = math.floor(maxz / 16)
info("Searching chunks: {},{} to {},{}".format(minx_chunk, minz_chunk, maxx_chunk, maxz_chunk))

minx_region = math.floor(minx / 512)
maxx_region = math.floor(maxx / 512)
minz_region = math.floor(minz / 512)
maxz_region = math.floor(maxz / 512)
info("Searching regions: {},{} to {},{}".format(minx_region, minz_region, maxx_region, maxz_region))

villagers = {}
now = time.time()

for region_x in range(minx_region, maxx_region + 1):
    for region_z in range(minz_region, maxz_region + 1):
        region_file = "{}/r.{}.{}.mca".format(region_files, region_x, region_z)
        info("Region file: {}".format(region_file))

        last_modified = now - os.path.getmtime(region_file)
        info("Last modified: {} seconds ago".format(last_modified))
        
        region = RegionFile(region_file)
        chunks = region.get_chunks()
        for chunk in chunks:
            x = chunk['x']
            z = chunk['z']
            chunk_nbt = region.get_chunk(x, z)
            xPos = chunk_nbt['Level']['xPos'].value
            zPos = chunk_nbt['Level']['zPos'].value
            if xPos >= minx_chunk and xPos <= maxx_chunk and zPos >= minz_chunk and zPos <= maxz_chunk:
                for entity in chunk_nbt['Level']['Entities']:
                    if entity['id'].value == 'minecraft:villager':
                        uuid = repr_uuid(entity['UUID'].value)
                        villager_x = entity['Pos'][0].value
                        villager_y = entity['Pos'][1].value
                        villager_z = entity['Pos'][2].value
                        if villager_x >= minx and villager_x <= maxx and villager_z >= minz and villager_z <= maxz:
                            villagers[uuid] = {
                                'x': villager_x,
                                'y': villager_y,
                                'z': villager_z,
                                'inventory': [(i[0].value, i[1].value) for i in entity['Inventory']],
                                'profession': entity['VillagerData']['profession'].value,
                                'profession_level': entity['VillagerData']['level'].value,
                                'age': entity['Age'].value + (last_modified * 20 * use_last_modified),
                                'health': entity['Health'].value,
                                'gossips': [(g['Type'].value, g['Value'].value, g['Target'].value) for g in entity['Gossips']],
                            }

profession_levels = ['Novice', 'Apprentice', 'Journeyman', 'Expert', 'Master']
for uuid, villager in sorted(villagers.items(), key=lambda v: v[1][sort_dim], reverse=sort_reverse):
    
    # UUID
    if show_uuid:
        print(uuid)
    
    # Profession
    profession = villager['profession']
    if profession != 'minecraft:none':
        profession += " - " + profession_levels[villager['profession_level'] - 1]
    
    # Age
    age = 'Adult'
    if villager['age'] < 0:
        seconds = round(-villager['age'] / 20)
        age = "{}:{:02d} until adult".format(math.floor(seconds / 60), seconds % 60)
        if use_last_modified == 1:
            age += " at {}".format(time.strftime("%H:%M:%S", time.localtime(now + seconds)))
    
    # Show basic info
    print("{} {} {} | {} | {} | {}â™¥".format(
        math.floor(villager['x']), math.floor(villager['y']), math.floor(villager['z']),
        profession, 
        age, 
        int(villager['health'])))
    
    # Show inventory
    for n, i in enumerate(villager['inventory']):
        print("[{}] {}: {}".format(n + 1, i[0], i[1]))
    for n in range(len(villager['inventory']) + 1, 9):
        print("[{}] -".format(n))
    
    # Show gossips
    if len(villager['gossips']) > 0:
        print("Gossips:")
        for g in villager['gossips']:
            g_uuid = repr_uuid(g[2])
            print("- {} {} {}".format(g[0], g[1], g_uuid))
    
    print()
